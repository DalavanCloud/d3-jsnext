{"version":3,"file":"bundle.js","sources":["/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/src/arrays/range.js","/www/d3-jsnext/src/math/abs.js","/www/d3-jsnext/src/arrays/range.js","/www/d3-jsnext/src/arrays/range.js","/www/d3-jsnext/src/geom/voronoi.js","/www/d3-jsnext/src/geom/voronoi.js","/www/d3-jsnext/src/core/functor.js","/www/d3-jsnext/src/geom/voronoi.js","/www/d3-jsnext/src/geom/voronoi/cell.js","/www/d3-jsnext/src/geom/voronoi/cell.js","/www/d3-jsnext/src/geom/voronoi/cell.js","/www/d3-jsnext/src/math/trigonometry.js","/www/d3-jsnext/src/geom/point.js","/www/d3-jsnext/src/geom/point.js","/www/d3-jsnext/src/geom/voronoi.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/document.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/vendor.js","/www/d3-jsnext/src/core/vendor.js","/www/d3-jsnext/src/selection/selection.js","","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/array.js","","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/ns.js","/www/d3-jsnext/src/core/ns.js","/www/d3-jsnext/src/core/ns.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/format/collapse.js","/www/d3-jsnext/src/format/requote.js","/www/d3-jsnext/src/format/requote.js","/www/d3-jsnext/src/format/requote.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/document.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/subclass.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/core/class.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/arrays/ascending.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/noop.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/arrays/map.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/src/core/document.js","","/www/d3-jsnext/src/selection/selection.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js","/www/d3-jsnext/examples/voronoi/main.js"],"sourcesContent":["import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { abs } from '../math/abs';\n\nvar d3$range;\n\nd3$range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       k = d3_range_integerScale(abs(step)),\n       i = -1,\n       j;\n  start *= k, stop *= k, step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);\n  else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n};\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}\n\nexport { d3$range, d3_range_integerScale };","var abs = Math.abs;\n\nexport { abs };","import { abs } from '../math/abs';\n\nvar d3$range;\n\nd3$range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       k = d3_range_integerScale(abs(step)),\n       i = -1,\n       j;\n  start *= k, stop *= k, step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);\n  else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n};\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}\n\nexport { d3$range, d3_range_integerScale };","import { abs } from '../math/abs';\n\nvar d3$range;\n\nd3$range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [],\n       k = d3_range_integerScale(abs(step)),\n       i = -1,\n       j;\n  start *= k, stop *= k, step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);\n  else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n};\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}\n\nexport { d3$range, d3_range_integerScale };","import { d3_functor } from '../core/functor';\nimport { d3_geom_voronoiHalfEdgeOrder } from './voronoi/cell';\nimport { ε } from '../math/trigonometry';\nimport { d3_geom_pointY, d3_geom_pointX } from './point';\nimport { d3$geom } from './geom';\n\nvar d3$geom$voronoi;\n\nd3$geom$voronoi = function(points) {\n  var x = d3_geom_pointX,\n      y = d3_geom_pointY,\n      fx = x,\n      fy = y,\n      clipExtent = d3_geom_voronoiClipExtent;\n\n  // @deprecated; use voronoi(data) instead.\n  if (points) return voronoi(points);\n\n  function voronoi(data) {\n    var polygons = new Array(data.length),\n        x0 = clipExtent[0][0],\n        y0 = clipExtent[0][1],\n        x1 = clipExtent[1][0],\n        y1 = clipExtent[1][1];\n\n    d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n      var edges = cell.edges,\n          site = cell.site,\n          polygon = polygons[i] = edges.length ? edges.map(function(e) { var s = e.start(); return [s.x, s.y]; })\n              : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]]\n              : [];\n      polygon.point = data[i];\n    });\n\n    return polygons;\n  }\n\n  function sites(data) {\n    return data.map(function(d, i) {\n      return {\n        x: Math.round(fx(d, i) / ε) * ε,\n        y: Math.round(fy(d, i) / ε) * ε,\n        i: i\n      };\n    });\n  }\n\n  voronoi.links = function(data) {\n    return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n      return edge.l && edge.r;\n    }).map(function(edge) {\n      return {\n        source: data[edge.l.i],\n        target: data[edge.r.i]\n      };\n    });\n  };\n\n  voronoi.triangles = function(data) {\n    var triangles = [];\n\n    d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n      var site = cell.site,\n          edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),\n          j = -1,\n          m = edges.length,\n          e0,\n          s0,\n          e1 = edges[m - 1].edge,\n          s1 = e1.l === site ? e1.r : e1.l;\n\n      while (++j < m) {\n        e0 = e1;\n        s0 = s1;\n        e1 = edges[j].edge;\n        s1 = e1.l === site ? e1.r : e1.l;\n        if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n          triangles.push([data[i], data[s0.i], data[s1.i]]);\n        }\n      }\n    });\n\n    return triangles;\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n  };\n\n  voronoi.clipExtent = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n    clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n    return voronoi;\n  };\n\n  // @deprecated; use clipExtent instead.\n  voronoi.size = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n    return voronoi.clipExtent(_ && [[0, 0], _]);\n  };\n\n  return voronoi;\n};\n\nvar d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];\n\nfunction d3_geom_voronoiTriangleArea(a, b, c) {\n  return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n}\n\nexport { d3$geom$voronoi, d3_geom_voronoiTriangleArea, d3_geom_voronoiClipExtent };","import { d3_functor } from '../core/functor';\nimport { d3_geom_voronoiHalfEdgeOrder } from './voronoi/cell';\nimport { ε } from '../math/trigonometry';\nimport { d3_geom_pointY, d3_geom_pointX } from './point';\nimport { d3$geom } from './geom';\n\nvar d3$geom$voronoi;\n\nd3$geom$voronoi = function(points) {\n  var x = d3_geom_pointX,\n      y = d3_geom_pointY,\n      fx = x,\n      fy = y,\n      clipExtent = d3_geom_voronoiClipExtent;\n\n  // @deprecated; use voronoi(data) instead.\n  if (points) return voronoi(points);\n\n  function voronoi(data) {\n    var polygons = new Array(data.length),\n        x0 = clipExtent[0][0],\n        y0 = clipExtent[0][1],\n        x1 = clipExtent[1][0],\n        y1 = clipExtent[1][1];\n\n    d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n      var edges = cell.edges,\n          site = cell.site,\n          polygon = polygons[i] = edges.length ? edges.map(function(e) { var s = e.start(); return [s.x, s.y]; })\n              : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]]\n              : [];\n      polygon.point = data[i];\n    });\n\n    return polygons;\n  }\n\n  function sites(data) {\n    return data.map(function(d, i) {\n      return {\n        x: Math.round(fx(d, i) / ε) * ε,\n        y: Math.round(fy(d, i) / ε) * ε,\n        i: i\n      };\n    });\n  }\n\n  voronoi.links = function(data) {\n    return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n      return edge.l && edge.r;\n    }).map(function(edge) {\n      return {\n        source: data[edge.l.i],\n        target: data[edge.r.i]\n      };\n    });\n  };\n\n  voronoi.triangles = function(data) {\n    var triangles = [];\n\n    d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n      var site = cell.site,\n          edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),\n          j = -1,\n          m = edges.length,\n          e0,\n          s0,\n          e1 = edges[m - 1].edge,\n          s1 = e1.l === site ? e1.r : e1.l;\n\n      while (++j < m) {\n        e0 = e1;\n        s0 = s1;\n        e1 = edges[j].edge;\n        s1 = e1.l === site ? e1.r : e1.l;\n        if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n          triangles.push([data[i], data[s0.i], data[s1.i]]);\n        }\n      }\n    });\n\n    return triangles;\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n  };\n\n  voronoi.clipExtent = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n    clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n    return voronoi;\n  };\n\n  // @deprecated; use clipExtent instead.\n  voronoi.size = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n    return voronoi.clipExtent(_ && [[0, 0], _]);\n  };\n\n  return voronoi;\n};\n\nvar d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];\n\nfunction d3_geom_voronoiTriangleArea(a, b, c) {\n  return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n}\n\nexport { d3$geom$voronoi, d3_geom_voronoiTriangleArea, d3_geom_voronoiClipExtent };","var d3_functor;\n\nfunction d3_functor(v) {\n  return typeof v === \"function\" ? v : function() { return v; };\n}\n\nd3$functor = d3_functor;\n\nexport { d3_functor };","import { d3_functor } from '../core/functor';\nimport { d3_geom_voronoiHalfEdgeOrder } from './voronoi/cell';\nimport { ε } from '../math/trigonometry';\nimport { d3_geom_pointY, d3_geom_pointX } from './point';\nimport { d3$geom } from './geom';\n\nvar d3$geom$voronoi;\n\nd3$geom$voronoi = function(points) {\n  var x = d3_geom_pointX,\n      y = d3_geom_pointY,\n      fx = x,\n      fy = y,\n      clipExtent = d3_geom_voronoiClipExtent;\n\n  // @deprecated; use voronoi(data) instead.\n  if (points) return voronoi(points);\n\n  function voronoi(data) {\n    var polygons = new Array(data.length),\n        x0 = clipExtent[0][0],\n        y0 = clipExtent[0][1],\n        x1 = clipExtent[1][0],\n        y1 = clipExtent[1][1];\n\n    d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n      var edges = cell.edges,\n          site = cell.site,\n          polygon = polygons[i] = edges.length ? edges.map(function(e) { var s = e.start(); return [s.x, s.y]; })\n              : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]]\n              : [];\n      polygon.point = data[i];\n    });\n\n    return polygons;\n  }\n\n  function sites(data) {\n    return data.map(function(d, i) {\n      return {\n        x: Math.round(fx(d, i) / ε) * ε,\n        y: Math.round(fy(d, i) / ε) * ε,\n        i: i\n      };\n    });\n  }\n\n  voronoi.links = function(data) {\n    return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n      return edge.l && edge.r;\n    }).map(function(edge) {\n      return {\n        source: data[edge.l.i],\n        target: data[edge.r.i]\n      };\n    });\n  };\n\n  voronoi.triangles = function(data) {\n    var triangles = [];\n\n    d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n      var site = cell.site,\n          edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),\n          j = -1,\n          m = edges.length,\n          e0,\n          s0,\n          e1 = edges[m - 1].edge,\n          s1 = e1.l === site ? e1.r : e1.l;\n\n      while (++j < m) {\n        e0 = e1;\n        s0 = s1;\n        e1 = edges[j].edge;\n        s1 = e1.l === site ? e1.r : e1.l;\n        if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n          triangles.push([data[i], data[s0.i], data[s1.i]]);\n        }\n      }\n    });\n\n    return triangles;\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n  };\n\n  voronoi.clipExtent = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n    clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n    return voronoi;\n  };\n\n  // @deprecated; use clipExtent instead.\n  voronoi.size = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n    return voronoi.clipExtent(_ && [[0, 0], _]);\n  };\n\n  return voronoi;\n};\n\nvar d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];\n\nfunction d3_geom_voronoiTriangleArea(a, b, c) {\n  return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n}\n\nexport { d3$geom$voronoi, d3_geom_voronoiTriangleArea, d3_geom_voronoiClipExtent };","import { ε } from '../../math/trigonometry';\nimport { abs } from '../../math/abs';\nimport { d3_geom_voronoiCreateBorderEdge, d3_geom_voronoiHalfEdge } from './edge';\n\nfunction d3_geom_voronoiCell(site) {\n  this.site = site;\n  this.edges = [];\n}\n\nd3_geom_voronoiCell.prototype.prepare = function() {\n  var halfEdges = this.edges,\n      iHalfEdge = halfEdges.length,\n      edge;\n\n  while (iHalfEdge--) {\n    edge = halfEdges[iHalfEdge].edge;\n    if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n  }\n\n  halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n  return halfEdges.length;\n};\n\nfunction d3_geom_voronoiCloseCells(extent) {\n  var x0 = extent[0][0],\n      x1 = extent[1][0],\n      y0 = extent[0][1],\n      y1 = extent[1][1],\n      x2,\n      y2,\n      x3,\n      y3,\n      cells = d3_geom_voronoiCells,\n      iCell = cells.length,\n      cell,\n      iHalfEdge,\n      halfEdges,\n      nHalfEdges,\n      start,\n      end;\n\n  while (iCell--) {\n    cell = cells[iCell];\n    if (!cell || !cell.prepare()) continue;\n    halfEdges = cell.edges;\n    nHalfEdges = halfEdges.length;\n    iHalfEdge = 0;\n    while (iHalfEdge < nHalfEdges) {\n      end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n      start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n      if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n        halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end,\n            abs(x3 - x0) < ε && y1 - y3 > ε ? {x: x0, y: abs(x2 - x0) < ε ? y2 : y1}\n            : abs(y3 - y1) < ε && x1 - x3 > ε ? {x: abs(y2 - y1) < ε ? x2 : x1, y: y1}\n            : abs(x3 - x1) < ε && y3 - y0 > ε ? {x: x1, y: abs(x2 - x1) < ε ? y2 : y0}\n            : abs(y3 - y0) < ε && x3 - x0 > ε ? {x: abs(y2 - y0) < ε ? x2 : x0, y: y0}\n            : null), cell.site, null));\n        ++nHalfEdges;\n      }\n    }\n  }\n}\n\nfunction d3_geom_voronoiHalfEdgeOrder(a, b) {\n  return b.angle - a.angle;\n}\n\nexport { d3_geom_voronoiHalfEdgeOrder, d3_geom_voronoiCloseCells, d3_geom_voronoiCell };","import { ε } from '../../math/trigonometry';\nimport { abs } from '../../math/abs';\nimport { d3_geom_voronoiCreateBorderEdge, d3_geom_voronoiHalfEdge } from './edge';\n\nfunction d3_geom_voronoiCell(site) {\n  this.site = site;\n  this.edges = [];\n}\n\nd3_geom_voronoiCell.prototype.prepare = function() {\n  var halfEdges = this.edges,\n      iHalfEdge = halfEdges.length,\n      edge;\n\n  while (iHalfEdge--) {\n    edge = halfEdges[iHalfEdge].edge;\n    if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n  }\n\n  halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n  return halfEdges.length;\n};\n\nfunction d3_geom_voronoiCloseCells(extent) {\n  var x0 = extent[0][0],\n      x1 = extent[1][0],\n      y0 = extent[0][1],\n      y1 = extent[1][1],\n      x2,\n      y2,\n      x3,\n      y3,\n      cells = d3_geom_voronoiCells,\n      iCell = cells.length,\n      cell,\n      iHalfEdge,\n      halfEdges,\n      nHalfEdges,\n      start,\n      end;\n\n  while (iCell--) {\n    cell = cells[iCell];\n    if (!cell || !cell.prepare()) continue;\n    halfEdges = cell.edges;\n    nHalfEdges = halfEdges.length;\n    iHalfEdge = 0;\n    while (iHalfEdge < nHalfEdges) {\n      end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n      start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n      if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n        halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end,\n            abs(x3 - x0) < ε && y1 - y3 > ε ? {x: x0, y: abs(x2 - x0) < ε ? y2 : y1}\n            : abs(y3 - y1) < ε && x1 - x3 > ε ? {x: abs(y2 - y1) < ε ? x2 : x1, y: y1}\n            : abs(x3 - x1) < ε && y3 - y0 > ε ? {x: x1, y: abs(x2 - x1) < ε ? y2 : y0}\n            : abs(y3 - y0) < ε && x3 - x0 > ε ? {x: abs(y2 - y0) < ε ? x2 : x0, y: y0}\n            : null), cell.site, null));\n        ++nHalfEdges;\n      }\n    }\n  }\n}\n\nfunction d3_geom_voronoiHalfEdgeOrder(a, b) {\n  return b.angle - a.angle;\n}\n\nexport { d3_geom_voronoiHalfEdgeOrder, d3_geom_voronoiCloseCells, d3_geom_voronoiCell };","import { ε } from '../../math/trigonometry';\nimport { abs } from '../../math/abs';\nimport { d3_geom_voronoiCreateBorderEdge, d3_geom_voronoiHalfEdge } from './edge';\n\nfunction d3_geom_voronoiCell(site) {\n  this.site = site;\n  this.edges = [];\n}\n\nd3_geom_voronoiCell.prototype.prepare = function() {\n  var halfEdges = this.edges,\n      iHalfEdge = halfEdges.length,\n      edge;\n\n  while (iHalfEdge--) {\n    edge = halfEdges[iHalfEdge].edge;\n    if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n  }\n\n  halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n  return halfEdges.length;\n};\n\nfunction d3_geom_voronoiCloseCells(extent) {\n  var x0 = extent[0][0],\n      x1 = extent[1][0],\n      y0 = extent[0][1],\n      y1 = extent[1][1],\n      x2,\n      y2,\n      x3,\n      y3,\n      cells = d3_geom_voronoiCells,\n      iCell = cells.length,\n      cell,\n      iHalfEdge,\n      halfEdges,\n      nHalfEdges,\n      start,\n      end;\n\n  while (iCell--) {\n    cell = cells[iCell];\n    if (!cell || !cell.prepare()) continue;\n    halfEdges = cell.edges;\n    nHalfEdges = halfEdges.length;\n    iHalfEdge = 0;\n    while (iHalfEdge < nHalfEdges) {\n      end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n      start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n      if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n        halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end,\n            abs(x3 - x0) < ε && y1 - y3 > ε ? {x: x0, y: abs(x2 - x0) < ε ? y2 : y1}\n            : abs(y3 - y1) < ε && x1 - x3 > ε ? {x: abs(y2 - y1) < ε ? x2 : x1, y: y1}\n            : abs(x3 - x1) < ε && y3 - y0 > ε ? {x: x1, y: abs(x2 - x1) < ε ? y2 : y0}\n            : abs(y3 - y0) < ε && x3 - x0 > ε ? {x: abs(y2 - y0) < ε ? x2 : x0, y: y0}\n            : null), cell.site, null));\n        ++nHalfEdges;\n      }\n    }\n  }\n}\n\nfunction d3_geom_voronoiHalfEdgeOrder(a, b) {\n  return b.angle - a.angle;\n}\n\nexport { d3_geom_voronoiHalfEdgeOrder, d3_geom_voronoiCloseCells, d3_geom_voronoiCell };","var ε = 1e-6,\n    ε2 = ε * ε,\n    π = Math.PI,\n    τ = 2 * π,\n    τε = τ - ε,\n    halfπ = π / 2,\n    d3_radians = π / 180,\n    d3_degrees = 180 / π;\n\nfunction d3_sgn(x) {\n  return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\n\n// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nfunction d3_cross2d(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n}\n\nfunction d3_acos(x) {\n  return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n}\n\nfunction d3_asin(x) {\n  return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n}\n\nfunction d3_sinh(x) {\n  return ((x = Math.exp(x)) - 1 / x) / 2;\n}\n\nfunction d3_cosh(x) {\n  return ((x = Math.exp(x)) + 1 / x) / 2;\n}\n\nfunction d3_tanh(x) {\n  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n}\n\nfunction d3_haversin(x) {\n  return (x = Math.sin(x / 2)) * x;\n}\n\nexport {\n  d3_haversin,\n  d3_tanh,\n  d3_cosh,\n  d3_sinh,\n  d3_asin,\n  d3_acos,\n  d3_cross2d,\n  d3_sgn,\n  ε,\n  ε2,\n  π,\n  τ,\n  τε,\n  halfπ,\n  d3_radians,\n  d3_degrees\n};","function d3_geom_pointX(d) {\n  return d[0];\n}\n\nfunction d3_geom_pointY(d) {\n  return d[1];\n}\n\nexport { d3_geom_pointY, d3_geom_pointX };","function d3_geom_pointX(d) {\n  return d[0];\n}\n\nfunction d3_geom_pointY(d) {\n  return d[1];\n}\n\nexport { d3_geom_pointY, d3_geom_pointX };","import { d3_functor } from '../core/functor';\nimport { d3_geom_voronoiHalfEdgeOrder } from './voronoi/cell';\nimport { ε } from '../math/trigonometry';\nimport { d3_geom_pointY, d3_geom_pointX } from './point';\nimport { d3$geom } from './geom';\n\nvar d3$geom$voronoi;\n\nd3$geom$voronoi = function(points) {\n  var x = d3_geom_pointX,\n      y = d3_geom_pointY,\n      fx = x,\n      fy = y,\n      clipExtent = d3_geom_voronoiClipExtent;\n\n  // @deprecated; use voronoi(data) instead.\n  if (points) return voronoi(points);\n\n  function voronoi(data) {\n    var polygons = new Array(data.length),\n        x0 = clipExtent[0][0],\n        y0 = clipExtent[0][1],\n        x1 = clipExtent[1][0],\n        y1 = clipExtent[1][1];\n\n    d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n      var edges = cell.edges,\n          site = cell.site,\n          polygon = polygons[i] = edges.length ? edges.map(function(e) { var s = e.start(); return [s.x, s.y]; })\n              : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]]\n              : [];\n      polygon.point = data[i];\n    });\n\n    return polygons;\n  }\n\n  function sites(data) {\n    return data.map(function(d, i) {\n      return {\n        x: Math.round(fx(d, i) / ε) * ε,\n        y: Math.round(fy(d, i) / ε) * ε,\n        i: i\n      };\n    });\n  }\n\n  voronoi.links = function(data) {\n    return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n      return edge.l && edge.r;\n    }).map(function(edge) {\n      return {\n        source: data[edge.l.i],\n        target: data[edge.r.i]\n      };\n    });\n  };\n\n  voronoi.triangles = function(data) {\n    var triangles = [];\n\n    d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n      var site = cell.site,\n          edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),\n          j = -1,\n          m = edges.length,\n          e0,\n          s0,\n          e1 = edges[m - 1].edge,\n          s1 = e1.l === site ? e1.r : e1.l;\n\n      while (++j < m) {\n        e0 = e1;\n        s0 = s1;\n        e1 = edges[j].edge;\n        s1 = e1.l === site ? e1.r : e1.l;\n        if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n          triangles.push([data[i], data[s0.i], data[s1.i]]);\n        }\n      }\n    });\n\n    return triangles;\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n  };\n\n  voronoi.clipExtent = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n    clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n    return voronoi;\n  };\n\n  // @deprecated; use clipExtent instead.\n  voronoi.size = function(_) {\n    if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n    return voronoi.clipExtent(_ && [[0, 0], _]);\n  };\n\n  return voronoi;\n};\n\nvar d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];\n\nfunction d3_geom_voronoiTriangleArea(a, b, c) {\n  return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n}\n\nexport { d3$geom$voronoi, d3_geom_voronoiTriangleArea, d3_geom_voronoiClipExtent };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3_document = window.document;\n\nfunction d3_documentElement(node) {\n  return node\n      && (node.ownerDocument // node is a Node\n      || node.document // node is a Window\n      || node).documentElement; // node is a Document\n}\n\nfunction d3_window(node) {\n  return node\n      && ((node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n        || (node.document && node) // node is a Window\n        || node.defaultView); // node is a Document\n}\n\nexport { d3_window, d3_documentElement, d3_document };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","function d3_vendorSymbol(object, name) {\n  if (name in object) return name;\n  name = name.charAt(0).toUpperCase() + name.slice(1);\n  for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n    var prefixName = d3_vendorPrefixes[i] + name;\n    if (prefixName in object) return prefixName;\n  }\n}\n\nvar d3_vendorPrefixes = [\"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\"];\n\nexport { d3_vendorPrefixes, d3_vendorSymbol };","function d3_vendorSymbol(object, name) {\n  if (name in object) return name;\n  name = name.charAt(0).toUpperCase() + name.slice(1);\n  for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n    var prefixName = d3_vendorPrefixes[i] + name;\n    if (prefixName in object) return prefixName;\n  }\n}\n\nvar d3_vendorPrefixes = [\"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\"];\n\nexport { d3_vendorPrefixes, d3_vendorSymbol };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","// Prefer Sizzle, if available.","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3_arraySlice = [].slice,\n    d3_array = function(list) { return d3_arraySlice.call(list); }; // conversion for NodeLists\n\nexport { d3_arraySlice, d3_array };"," // conversion for NodeLists","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3$ns;\n\nvar d3_nsPrefix = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: \"http://www.w3.org/1999/xhtml\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nd3$ns = {\n  prefix: d3_nsPrefix,\n  qualify: function(name) {\n    var i = name.indexOf(\":\"),\n        prefix = name;\n    if (i >= 0) {\n      prefix = name.slice(0, i);\n      name = name.slice(i + 1);\n    }\n    return d3_nsPrefix.hasOwnProperty(prefix)\n        ? {space: d3_nsPrefix[prefix], local: name}\n        : name;\n  }\n};\n\nexport { d3$ns, d3_nsPrefix };","var d3$ns;\n\nvar d3_nsPrefix = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: \"http://www.w3.org/1999/xhtml\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nd3$ns = {\n  prefix: d3_nsPrefix,\n  qualify: function(name) {\n    var i = name.indexOf(\":\"),\n        prefix = name;\n    if (i >= 0) {\n      prefix = name.slice(0, i);\n      name = name.slice(i + 1);\n    }\n    return d3_nsPrefix.hasOwnProperty(prefix)\n        ? {space: d3_nsPrefix[prefix], local: name}\n        : name;\n  }\n};\n\nexport { d3$ns, d3_nsPrefix };","var d3$ns;\n\nvar d3_nsPrefix = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: \"http://www.w3.org/1999/xhtml\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nd3$ns = {\n  prefix: d3_nsPrefix,\n  qualify: function(name) {\n    var i = name.indexOf(\":\"),\n        prefix = name;\n    if (i >= 0) {\n      prefix = name.slice(0, i);\n      name = name.slice(i + 1);\n    }\n    return d3_nsPrefix.hasOwnProperty(prefix)\n        ? {space: d3_nsPrefix[prefix], local: name}\n        : name;\n  }\n};\n\nexport { d3$ns, d3_nsPrefix };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","function d3_collapse(s) {\n  return s.trim().replace(/\\s+/g, \" \");\n}\n\nexport { d3_collapse };","var d3$requote;\n\nd3$requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\nexport { d3$requote, d3_requote_re };","var d3$requote;\n\nd3$requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\nexport { d3$requote, d3_requote_re };","var d3$requote;\n\nd3$requote = function(s) {\n  return s.replace(d3_requote_re, \"\\\\$&\");\n};\n\nvar d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\nexport { d3$requote, d3_requote_re };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","// Multiple class names are allowed (e.g., \"foo bar\").","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3_document = window.document;\n\nfunction d3_documentElement(node) {\n  return node\n      && (node.ownerDocument // node is a Node\n      || node.document // node is a Window\n      || node).documentElement; // node is a Document\n}\n\nfunction d3_window(node) {\n  return node\n      && ((node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n        || (node.document && node) // node is a Window\n        || node.defaultView); // node is a Document\n}\n\nexport { d3_window, d3_documentElement, d3_document };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3_subclass = {}.__proto__?\n\n// Until ECMAScript supports array subclassing, prototype injection works well.\nfunction(object, prototype) {\n  object.__proto__ = prototype;\n}:\n\n// And if your browser doesn't support __proto__, we'll use direct extension.\nfunction(object, prototype) {\n  for (var property in prototype) object[property] = prototype[property];\n};\n\nexport { d3_subclass };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","function d3_class(ctor, properties) {\n  for (var key in properties) {\n    Object.defineProperty(ctor.prototype, key, {\n      value: properties[key],\n      enumerable: false\n    });\n  }\n}\n\nexport { d3_class };","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3_ascending;\n\nd3$ascending = d3_ascending;\n\nfunction d3_ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nexport { d3_ascending };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","function d3_noop() {}\n\nexport { d3_noop };","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_class } from '../core/class';\n\nvar d3$map;\n\nd3$map = function(object, f) {\n  var map = new d3_Map;\n  if (object instanceof d3_Map) {\n    object.forEach(function(key, value) { map.set(key, value); });\n  } else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n    if (arguments.length === 1) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n  } else {\n    for (var key in object) map.set(key, object[key]);\n  }\n  return map;\n};\n\nfunction d3_Map() {\n  this._ = Object.create(null);\n}\n\nvar d3_map_proto = \"__proto__\",\n    d3_map_zero = \"\\0\";\n\nd3_class(d3_Map, {\n  has: d3_map_has,\n  get: function(key) {\n    return this._[d3_map_escape(key)];\n  },\n  set: function(key, value) {\n    return this._[d3_map_escape(key)] = value;\n  },\n  remove: d3_map_remove,\n  keys: d3_map_keys,\n  values: function() {\n    var values = [];\n    for (var key in this._) values.push(this._[key]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var key in this._) entries.push({key: d3_map_unescape(key), value: this._[key]});\n    return entries;\n  },\n  size: d3_map_size,\n  empty: d3_map_empty,\n  forEach: function(f) {\n    for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n  }\n});\n\nfunction d3_map_escape(key) {\n  return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n}\n\nfunction d3_map_unescape(key) {\n  return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n}\n\nfunction d3_map_has(key) {\n  return d3_map_escape(key) in this._;\n}\n\nfunction d3_map_remove(key) {\n  return (key = d3_map_escape(key)) in this._ && delete this._[key];\n}\n\nfunction d3_map_keys() {\n  var keys = [];\n  for (var key in this._) keys.push(d3_map_unescape(key));\n  return keys;\n}\n\nfunction d3_map_size() {\n  var size = 0;\n  for (var key in this._) ++size;\n  return size;\n}\n\nfunction d3_map_empty() {\n  for (var key in this._) return false;\n  return true;\n}\n\nexport {\n  d3$map,\n  d3_map_empty,\n  d3_map_size,\n  d3_map_keys,\n  d3_map_remove,\n  d3_map_has,\n  d3_map_unescape,\n  d3_map_escape,\n  d3_map_proto,\n  d3_map_zero,\n  d3_Map\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","var d3_document = window.document;\n\nfunction d3_documentElement(node) {\n  return node\n      && (node.ownerDocument // node is a Node\n      || node.document // node is a Window\n      || node).documentElement; // node is a Document\n}\n\nfunction d3_window(node) {\n  return node\n      && ((node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n        || (node.document && node) // node is a Window\n        || node.defaultView); // node is a Document\n}\n\nexport { d3_window, d3_documentElement, d3_document };","// TODO fast singleton implementation?","import { d3_document, d3_documentElement, d3_window } from '../core/document';\nimport { d3_array } from '../core/array';\nimport { d3_subclass } from '../core/subclass';\nimport { d3_noop } from '../core/noop';\nimport { d3_ascending } from '../arrays/ascending';\nimport { d3_Map, d3$map } from '../arrays/map';\nimport { d3_collapse } from '../format/collapse';\nimport { d3_vendorSymbol } from '../core/vendor';\nimport { d3$requote } from '../format/requote';\nimport { d3$ns } from '../core/ns';\n\nvar d3$selectAll;\nvar d3$select;\nvar d3_selection_enter;\nvar d3$selection;\n\nfunction d3_selection(groups) {\n  d3_subclass(groups, d3_selectionPrototype);\n  return groups;\n}\n\nvar d3_select = function(s, n) { return n.querySelector(s); },\n    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },\n    d3_selectMatches = function(n, s) {\n      var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n      d3_selectMatches = function(n, s) {\n        return d3_selectMatcher.call(n, s);\n      };\n      return d3_selectMatches(n, s);\n    };\n\n// Prefer Sizzle, if available.\nif (typeof Sizzle === \"function\") {\n  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };\n  d3_selectAll = Sizzle;\n  d3_selectMatches = Sizzle.matchesSelector;\n}\n\nd3$selection = function() {\n  return d3$select(d3_document.documentElement);\n};\n\nvar d3_selectionPrototype = d3$selection.prototype = [];\n\nd3_selectionPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      group,\n      node;\n\n  selector = d3_selection_selector(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n        if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selector(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_select(selector, this);\n  };\n}\n\nd3_selectionPrototype.selectAll = function(selector) {\n  var subgroups = [],\n      subgroup,\n      node;\n\n  selector = d3_selection_selectorAll(selector);\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n        subgroup.parentNode = node;\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_selectorAll(selector) {\n  return typeof selector === \"function\" ? selector : function() {\n    return d3_selectAll(selector, this);\n  };\n}\n\nd3_selectionPrototype.attr = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For attr(string), return the attribute value for the first node.\n    if (typeof name === \"string\") {\n      var node = this.node();\n      name = d3$ns.qualify(name);\n      return name.local\n          ? node.getAttributeNS(name.space, name.local)\n          : node.getAttribute(name);\n    }\n\n    // For attr(object), the object specifies the names and values of the\n    // attributes to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_attr(value, name[value]));\n    return this;\n  }\n\n  return this.each(d3_selection_attr(name, value));\n};\n\nfunction d3_selection_attr(name, value) {\n  name = d3$ns.qualify(name);\n\n  // For attr(string, null), remove the attribute with the specified name.\n  function attrNull() {\n    this.removeAttribute(name);\n  }\n  function attrNullNS() {\n    this.removeAttributeNS(name.space, name.local);\n  }\n\n  // For attr(string, string), set the attribute with the specified name.\n  function attrConstant() {\n    this.setAttribute(name, value);\n  }\n  function attrConstantNS() {\n    this.setAttributeNS(name.space, name.local, value);\n  }\n\n  // For attr(string, function), evaluate the function for each element, and set\n  // or remove the attribute as appropriate.\n  function attrFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttribute(name);\n    else this.setAttribute(name, x);\n  }\n  function attrFunctionNS() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.removeAttributeNS(name.space, name.local);\n    else this.setAttributeNS(name.space, name.local, x);\n  }\n\n  return value == null\n      ? (name.local ? attrNullNS : attrNull) : (typeof value === \"function\"\n      ? (name.local ? attrFunctionNS : attrFunction)\n      : (name.local ? attrConstantNS : attrConstant));\n}\n\nd3_selectionPrototype.classed = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For classed(string), return true only if the first node has the specified\n    // class or classes. Note that even if the browser supports DOMTokenList, it\n    // probably doesn't support it on SVG elements (which can be animated).\n    if (typeof name === \"string\") {\n      var node = this.node(),\n          n = (name = d3_selection_classes(name)).length,\n          i = -1;\n      if (value = node.classList) {\n        while (++i < n) if (!value.contains(name[i])) return false;\n      } else {\n        value = node.getAttribute(\"class\");\n        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n      }\n      return true;\n    }\n\n    // For classed(object), the object specifies the names of classes to add or\n    // remove. The values may be functions that are evaluated for each element.\n    for (value in name) this.each(d3_selection_classed(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_classed(name, value));\n};\n\nfunction d3_selection_classedRe(name) {\n  return new RegExp(\"(?:^|\\\\s+)\" + d3$requote(name) + \"(?:\\\\s+|$)\", \"g\");\n}\n\nfunction d3_selection_classes(name) {\n  return (name + \"\").trim().split(/^|\\s+/);\n}\n\n// Multiple class names are allowed (e.g., \"foo bar\").\nfunction d3_selection_classed(name, value) {\n  name = d3_selection_classes(name).map(d3_selection_classedName);\n  var n = name.length;\n\n  function classedConstant() {\n    var i = -1;\n    while (++i < n) name[i](this, value);\n  }\n\n  // When the value is a function, the function is still evaluated only once per\n  // element even if there are multiple class names.\n  function classedFunction() {\n    var i = -1, x = value.apply(this, arguments);\n    while (++i < n) name[i](this, x);\n  }\n\n  return typeof value === \"function\"\n      ? classedFunction\n      : classedConstant;\n}\n\nfunction d3_selection_classedName(name) {\n  var re = d3_selection_classedRe(name);\n  return function(node, value) {\n    if (c = node.classList) return value ? c.add(name) : c.remove(name);\n    var c = node.getAttribute(\"class\") || \"\";\n    if (value) {\n      re.lastIndex = 0;\n      if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n    } else {\n      node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n    }\n  };\n}\n\nd3_selectionPrototype.style = function(name, value, priority) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For style(object) or style(object, string), the object specifies the\n    // names and values of the attributes to set or remove. The values may be\n    // functions that are evaluated for each element. The optional string\n    // specifies the priority.\n    if (typeof name !== \"string\") {\n      if (n < 2) value = \"\";\n      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n      return this;\n    }\n\n    // For style(string), return the computed style value for the first node.\n    if (n < 2) {\n      var node = this.node();\n      return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n    }\n\n    // For style(string, string) or style(string, function), use the default\n    // priority. The priority is ignored for style(string, null).\n    priority = \"\";\n  }\n\n  // Otherwise, a name, value and priority are specified, and handled as below.\n  return this.each(d3_selection_style(name, value, priority));\n};\n\nfunction d3_selection_style(name, value, priority) {\n\n  // For style(name, null) or style(name, null, priority), remove the style\n  // property with the specified name. The priority is ignored.\n  function styleNull() {\n    this.style.removeProperty(name);\n  }\n\n  // For style(name, string) or style(name, string, priority), set the style\n  // property with the specified name, using the specified priority.\n  function styleConstant() {\n    this.style.setProperty(name, value, priority);\n  }\n\n  // For style(name, function) or style(name, function, priority), evaluate the\n  // function for each element, and set or remove the style property as\n  // appropriate. When setting, use the specified priority.\n  function styleFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, x, priority);\n  }\n\n  return value == null\n      ? styleNull : (typeof value === \"function\"\n      ? styleFunction : styleConstant);\n}\n\nd3_selectionPrototype.property = function(name, value) {\n  if (arguments.length < 2) {\n\n    // For property(string), return the property value for the first node.\n    if (typeof name === \"string\") return this.node()[name];\n\n    // For property(object), the object specifies the names and values of the\n    // properties to set or remove. The values may be functions that are\n    // evaluated for each element.\n    for (value in name) this.each(d3_selection_property(value, name[value]));\n    return this;\n  }\n\n  // Otherwise, both a name and a value are specified, and are handled as below.\n  return this.each(d3_selection_property(name, value));\n};\n\nfunction d3_selection_property(name, value) {\n\n  // For property(name, null), remove the property with the specified name.\n  function propertyNull() {\n    delete this[name];\n  }\n\n  // For property(name, string), set the property with the specified name.\n  function propertyConstant() {\n    this[name] = value;\n  }\n\n  // For property(name, function), evaluate the function for each element, and\n  // set or remove the property as appropriate.\n  function propertyFunction() {\n    var x = value.apply(this, arguments);\n    if (x == null) delete this[name];\n    else this[name] = x;\n  }\n\n  return value == null\n      ? propertyNull : (typeof value === \"function\"\n      ? propertyFunction : propertyConstant);\n}\n\nd3_selectionPrototype.text = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; } : value == null\n      ? function() { this.textContent = \"\"; }\n      : function() { this.textContent = value; })\n      : this.node().textContent;\n};\n\nd3_selectionPrototype.html = function(value) {\n  return arguments.length\n      ? this.each(typeof value === \"function\"\n      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; } : value == null\n      ? function() { this.innerHTML = \"\"; }\n      : function() { this.innerHTML = value; })\n      : this.node().innerHTML;\n};\n\nd3_selectionPrototype.append = function(name) {\n  name = d3_selection_creator(name);\n  return this.select(function() {\n    return this.appendChild(name.apply(this, arguments));\n  });\n};\n\nfunction d3_selection_creator(name) {\n\n  function create() {\n    var document = this.ownerDocument,\n        namespace = this.namespaceURI;\n    return namespace\n        ? document.createElementNS(namespace, name)\n        : document.createElement(name);\n  }\n\n  function createNS() {\n    return this.ownerDocument.createElementNS(name.space, name.local);\n  }\n\n  return typeof name === \"function\" ? name\n      : (name = d3$ns.qualify(name)).local ? createNS\n      : create;\n}\n\nd3_selectionPrototype.insert = function(name, before) {\n  name = d3_selection_creator(name);\n  before = d3_selection_selector(before);\n  return this.select(function() {\n    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n  });\n};\n\n// TODO remove(selector)?\n// TODO remove(node)?\n// TODO remove(function)?\nd3_selectionPrototype.remove = function() {\n  return this.each(d3_selectionRemove);\n};\n\nfunction d3_selectionRemove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nd3_selectionPrototype.data = function(value, key) {\n  var i = -1,\n      n = this.length,\n      group,\n      node;\n\n  // If no value is specified, return the first value.\n  if (!arguments.length) {\n    value = new Array(n = (group = this[0]).length);\n    while (++i < n) {\n      if (node = group[i]) {\n        value[i] = node.__data__;\n      }\n    }\n    return value;\n  }\n\n  function bind(group, groupData) {\n    var i,\n        n = group.length,\n        m = groupData.length,\n        n0 = Math.min(n, m),\n        updateNodes = new Array(m),\n        enterNodes = new Array(m),\n        exitNodes = new Array(n),\n        node,\n        nodeData;\n\n    if (key) {\n      var nodeByKeyValue = new d3_Map,\n          keyValues = new Array(n),\n          keyValue;\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {\n          exitNodes[i] = node; // duplicate selection key\n        } else {\n          nodeByKeyValue.set(keyValue, node);\n        }\n        keyValues[i] = keyValue;\n      }\n\n      for (i = -1; ++i < m;) {\n        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        } else if (node !== true) { // no duplicate data key\n          updateNodes[i] = node;\n          node.__data__ = nodeData;\n        }\n        nodeByKeyValue.set(keyValue, true);\n      }\n\n      for (i = -1; ++i < n;) {\n        if (nodeByKeyValue.get(keyValues[i]) !== true) {\n          exitNodes[i] = group[i];\n        }\n      }\n    } else {\n      for (i = -1; ++i < n0;) {\n        node = group[i];\n        nodeData = groupData[i];\n        if (node) {\n          node.__data__ = nodeData;\n          updateNodes[i] = node;\n        } else {\n          enterNodes[i] = d3_selection_dataNode(nodeData);\n        }\n      }\n      for (; i < m; ++i) {\n        enterNodes[i] = d3_selection_dataNode(groupData[i]);\n      }\n      for (; i < n; ++i) {\n        exitNodes[i] = group[i];\n      }\n    }\n\n    enterNodes.update\n        = updateNodes;\n\n    enterNodes.parentNode\n        = updateNodes.parentNode\n        = exitNodes.parentNode\n        = group.parentNode;\n\n    enter.push(enterNodes);\n    update.push(updateNodes);\n    exit.push(exitNodes);\n  }\n\n  var enter = d3_selection_enter([]),\n      update = d3_selection([]),\n      exit = d3_selection([]);\n\n  if (typeof value === \"function\") {\n    while (++i < n) {\n      bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n    }\n  } else {\n    while (++i < n) {\n      bind(group = this[i], value);\n    }\n  }\n\n  update.enter = function() { return enter; };\n  update.exit = function() { return exit; };\n  return update;\n};\n\nfunction d3_selection_dataNode(data) {\n  return {__data__: data};\n}\n\nd3_selectionPrototype.datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.property(\"__data__\");\n};\n\nd3_selectionPrototype.filter = function(filter) {\n  var subgroups = [],\n      subgroup,\n      group,\n      node;\n\n  if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n  for (var j = 0, m = this.length; j < m; j++) {\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = (group = this[j]).parentNode;\n    for (var i = 0, n = group.length; i < n; i++) {\n      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nfunction d3_selection_filter(selector) {\n  return function() {\n    return d3_selectMatches(this, selector);\n  };\n}\n\nd3_selectionPrototype.order = function() {\n  for (var j = -1, m = this.length; ++j < m;) {\n    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n};\n\nd3_selectionPrototype.sort = function(comparator) {\n  comparator = d3_selection_sortComparator.apply(this, arguments);\n  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n  return this.order();\n};\n\nfunction d3_selection_sortComparator(comparator) {\n  if (!arguments.length) comparator = d3_ascending;\n  return function(a, b) {\n    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n  };\n}\n\nd3_selectionPrototype.on = function(type, listener, capture) {\n  var n = arguments.length;\n  if (n < 3) {\n\n    // For on(object) or on(object, boolean), the object specifies the event\n    // types and listeners to add or remove. The optional boolean specifies\n    // whether the listener captures events.\n    if (typeof type !== \"string\") {\n      if (n < 2) listener = false;\n      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n      return this;\n    }\n\n    // For on(string), return the listener for the first node.\n    if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n\n    // For on(string, function), use the default capture.\n    capture = false;\n  }\n\n  // Otherwise, a type, listener and capture are specified, and handled as below.\n  return this.each(d3_selection_on(type, listener, capture));\n};\n\nfunction d3_selection_on(type, listener, capture) {\n  var name = \"__on\" + type,\n      i = type.indexOf(\".\"),\n      wrap = d3_selection_onListener;\n\n  if (i > 0) type = type.slice(0, i);\n  var filter = d3_selection_onFilters.get(type);\n  if (filter) type = filter, wrap = d3_selection_onFilter;\n\n  function onRemove() {\n    var l = this[name];\n    if (l) {\n      this.removeEventListener(type, l, l.$);\n      delete this[name];\n    }\n  }\n\n  function onAdd() {\n    var l = wrap(listener, d3_array(arguments));\n    onRemove.call(this);\n    this.addEventListener(type, this[name] = l, l.$ = capture);\n    l._ = listener;\n  }\n\n  function removeAll() {\n    var re = new RegExp(\"^__on([^.]+)\" + d3$requote(type) + \"$\"),\n        match;\n    for (var name in this) {\n      if (match = name.match(re)) {\n        var l = this[name];\n        this.removeEventListener(match[1], l, l.$);\n        delete this[name];\n      }\n    }\n  }\n\n  return i\n      ? listener ? onAdd : onRemove\n      : listener ? d3_noop : removeAll;\n}\n\nvar d3_selection_onFilters = d3$map({\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n});\n\nif (d3_document) {\n  d3_selection_onFilters.forEach(function(k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n}\n\nfunction d3_selection_onListener(listener, argumentz) {\n  return function(e) {\n    var o = window.d3_event; // Events can be reentrant (e.g., focus).\n    window.d3_event = e;\n    argumentz[0] = this.__data__;\n    try {\n      listener.apply(this, argumentz);\n    } finally {\n      window.d3_event = o;\n    }\n  };\n}\n\nfunction d3_selection_onFilter(listener, argumentz) {\n  var l = d3_selection_onListener(listener, argumentz);\n  return function(e) {\n    var target = this, related = e.relatedTarget;\n    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {\n      l.call(target, e);\n    }\n  };\n}\n\nd3_selectionPrototype.each = function(callback) {\n  return d3_selection_each(this, function(node, i, j) {\n    callback.call(node, node.__data__, i, j);\n  });\n};\n\nfunction d3_selection_each(groups, callback) {\n  for (var j = 0, m = groups.length; j < m; j++) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n      if (node = group[i]) callback(node, i, j);\n    }\n  }\n  return groups;\n}\n\nd3_selectionPrototype.call = function(callback) {\n  var args = d3_array(arguments);\n  callback.apply(args[0] = this, args);\n  return this;\n};\n\nd3_selectionPrototype.empty = function() {\n  return !this.node();\n};\n\nd3_selectionPrototype.node = function() {\n  for (var j = 0, m = this.length; j < m; j++) {\n    for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n};\n\nd3_selectionPrototype.size = function() {\n  var n = 0;\n  d3_selection_each(this, function() { ++n; });\n  return n;\n};\n\nfunction d3_selection_enter(selection) {\n  d3_subclass(selection, d3_selection_enterPrototype);\n  return selection;\n}\n\nvar d3_selection_enterPrototype = [];\n\nd3$selection$enter = d3_selection_enter;\nd3$selection$enter.prototype = d3_selection_enterPrototype;\n\nd3_selection_enterPrototype.append = d3_selectionPrototype.append;\nd3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\nd3_selection_enterPrototype.node = d3_selectionPrototype.node;\nd3_selection_enterPrototype.call = d3_selectionPrototype.call;\nd3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\nd3_selection_enterPrototype.select = function(selector) {\n  var subgroups = [],\n      subgroup,\n      subnode,\n      upgroup,\n      group,\n      node;\n\n  for (var j = -1, m = this.length; ++j < m;) {\n    upgroup = (group = this[j]).update;\n    subgroups.push(subgroup = []);\n    subgroup.parentNode = group.parentNode;\n    for (var i = -1, n = group.length; ++i < n;) {\n      if (node = group[i]) {\n        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n        subnode.__data__ = node.__data__;\n      } else {\n        subgroup.push(null);\n      }\n    }\n  }\n\n  return d3_selection(subgroups);\n};\n\nd3_selection_enterPrototype.insert = function(name, before) {\n  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n  return d3_selectionPrototype.insert.call(this, name, before);\n};\n\nfunction d3_selection_enterInsertBefore(enter) {\n  var i0, j0;\n  return function(d, i, j) {\n    var group = enter[j].update,\n        n = group.length,\n        node;\n    if (j != j0) j0 = j, i0 = 0;\n    if (i >= i0) i0 = i + 1;\n    while (!(node = group[i0]) && ++i0 < n);\n    return node;\n  };\n}\n\n\n// TODO fast singleton implementation?\nd3$select = function(node) {\n  var group;\n  if (typeof node === \"string\") {\n    group = [d3_select(node, d3_document)];\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = [node];\n    group.parentNode = d3_documentElement(node);\n  }\n  return d3_selection([group]);\n};\n\nd3$selectAll = function(nodes) {\n  var group;\n  if (typeof nodes === \"string\") {\n    group = d3_array(d3_selectAll(nodes, d3_document));\n    group.parentNode = d3_document.documentElement;\n  } else {\n    group = nodes;\n    group.parentNode = null;\n  }\n  return d3_selection([group]);\n};\n\nexport {\n  d3$selectAll,\n  d3$select,\n  d3_selection_enter,\n  d3$selection,\n  d3_selection_enterInsertBefore,\n  d3_selection_enterPrototype,\n  d3_selection_each,\n  d3_selection_onFilter,\n  d3_selection_onListener,\n  d3_selection_onFilters,\n  d3_selection_on,\n  d3_selection_sortComparator,\n  d3_selection_filter,\n  d3_selection_dataNode,\n  d3_selectionRemove,\n  d3_selection_creator,\n  d3_selection_property,\n  d3_selection_style,\n  d3_selection_classedName,\n  d3_selection_classed,\n  d3_selection_classes,\n  d3_selection_classedRe,\n  d3_selection_attr,\n  d3_selection_selectorAll,\n  d3_selection_selector,\n  d3_selectionPrototype,\n  d3_select,\n  d3_selectAll,\n  d3_selectMatches,\n  d3_selection\n};","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n","import { range, select, geom$voronoi as voronoi } from '../../src/index'; // TODO just voronoi\n\nvar width = 960,\n    height = 500;\n\nvar vertices = range(100).map(function(d) {\n  return [Math.random() * width, Math.random() * height];\n});\n\nvar layout = voronoi()\n    .clipExtent([[0, 0], [width, height]]);\n\nvar svg = select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .on(\"mousemove\", function() { vertices[0] = d3.mouse(this); redraw(); });\n\nvar path = svg.append(\"g\").selectAll(\"path\");\n\nsvg.selectAll(\"circle\")\n    .data(vertices.slice(1))\n  .enter().append(\"circle\")\n    .attr(\"transform\", function(d) { return \"translate(\" + d + \")\"; })\n    .attr(\"r\", 1.5);\n\nredraw();\n\nfunction redraw() {\n  path = path\n      .data(layout(vertices), polygon);\n\n  path.exit().remove();\n\n  path.enter().append(\"path\")\n      .attr(\"class\", function(d, i) { return \"q\" + (i % 9) + \"-9\"; })\n      .attr(\"d\", polygon);\n\n  path.order();\n}\n\nfunction polygon(d) {\n  return \"M\" + d.join(\"L\") + \"Z\";\n}\n"],"names":[],"mappings":"AAEA;AACAACDAACFAACuBA;AACA;AACA;AACA;AACAACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACfAACsGAAC1GA;AACA;AACAAC0GA;AACA;AACAACjDA;AACA;AACAAC7DA;AACA;AACA;AACAACEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACAACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACHA;AACA;AACAACNA;AACA;AACAACMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACAAC9FAACEAACdAACsCA;AACA;AACAACEAACjCAACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAAC7BAACgCA;AACA;AACA;AACA;AACAACiCA;AACA;AACA;AACA;AACAAC7BA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACAACnEA;AACAACDAAC8FA;AACA;AACA;AACA;AACAACvBA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACAAC5FAACEA;AACA;AACA;AACA;AACA;AACA;AACAACEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACmGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACAAC1DA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACAACxHA;AACA;AACAACFAACMAACJA;AACA;AACAACyLA;AACA;AACAAC4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACtCA;AACA;AACAACnMAACsMA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACAACzDA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACAAC2EA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACAACvRA;AACA;AACA;AACA;AACA;AACAAC2NA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACAAC+CA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACAACxCA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACAAC2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACSA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACAACxBA;AACA;AACA;AACA;AACA;AACAACqBA;AACA;AACA;AACA;AACA;AACA;AACAACSA;AACA;AACA;AACAAC1YA;AACA;AACAACiYA;AACA;AACAACkUAACKAACCAACCAACCAACCAACEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACAACOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAAChBA;AACA;AACA;AACAAC9uBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACAACwrBA;AACA;AACA;AACAAC7MA;AACA;AACAACteA;AACA;AACAACEA;AACAACiCA;AACA;AACAACsBA;AACA;AACA;AACAACTA;AACA;AACA;AACA;AACAACVA;AACA;AACA;AACA;AACAACpBA;AACA;AACAACUA;AACA;AACAACNA;AACA;AACAAChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACwVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACAACMA;AACA;AACA;AACA;AACAACuBA;AACA;AACA;AACA;AACAACzBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACAACQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACniBA;AACA;AACAACyiBA;AACA;AACA;AACA;AACA;AACAACXA;AACA;AACA;AACA;AACAAC7iBAACkoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACrpBAACEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACqmBA;AACA;AACA;AACAAC5CA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACAAC/DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACAACmFA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACbA;AACA;AACA;AACA;AACAACWA;AACA;AACA;AACA;AACAACEA;AACA;AACAACEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACEA;AACA;AACA;AACA;AACAAChrBA;AACA;AACA;AACAACjBA;AACA;AACA;AACA;AACA;AACAACPAAC+vBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAACpwBA,eALA,QAKoB;AACpB;AACAACEA,aATA,eASoB;AACpBACEA,UAZA,SAYgB;AAChB;AACA;AACAACEAACEA;AACA;AACA;AACA;AACAACEAACEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACAACEA;AACA;AACA"}